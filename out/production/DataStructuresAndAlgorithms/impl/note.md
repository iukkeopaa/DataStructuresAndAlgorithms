## 链表实现栈

 5  - head
 |
 2
 |
 3
 |
 1  - tail
 
## 数组实现栈

5  - tail   6  index
|           
2           4
|           
3           2 
|           
1  - head   0


## 对比

### 1. 代码实现复杂度

- **数组实现**： 数组实现栈相对简单直接。在初始化时，只需分配固定大小的数组空间，并且入栈、出栈等操作都是基于数组索引进行，代码逻辑容易理解。像前面给出的 Java 数组实现栈的代码，只需要维护一个表示栈顶位置的索引 `top` 就可以完成主要操作。
- **链表实现**： 链表实现栈需要定义节点类，并且在入栈和出栈时要处理节点的创建和删除操作，涉及指针的操作，代码实现相对复杂。例如在 Java 中实现链表栈，需要定义节点类包含数据和指向下一个节点的引用，入栈和出栈时要更新节点的引用关系。

### 2. 空间复杂度

- **数组实现**： 数组在创建时需要预先分配固定大小的空间，这可能会导致空间的浪费。如果栈中元素较少，而数组空间较大，就会有很多空闲的数组位置。不过它的空间复杂度是固定的 \(O(n)\)，其中 n 是数组的容量。
- **链表实现**： 链表实现栈是动态分配空间的，每个节点在需要时才会被创建，不会有预先分配过多空间的问题。但是每个节点除了存储数据，还需要额外的指针来指向下一个节点，会有一定的额外空间开销。总体来说，链表栈的空间复杂度也是 \(O(m)\)，其中 m 是栈中实际元素的数量。

### 3. 时间复杂度

- 入栈操作（Push）

  ：

    - **数组实现**：在数组未满的情况下，入栈操作只需要将元素放到数组的 `top + 1` 位置，然后更新 `top` 索引，时间复杂度为 \(O(1)\)。但如果数组已满，需要进行扩容操作，扩容时需要创建一个更大的数组并将原数组元素复制过去，时间复杂度会达到 \(O(n)\)，不过平均情况下入栈操作的时间复杂度仍然接近 \(O(1)\)。
    - **链表实现**：链表实现栈的入栈操作只需要创建一个新节点，然后将新节点插入到链表头部，更新头指针，时间复杂度始终为 \(O(1)\)。

- 出栈操作（Pop）

  ：

    - **数组实现**：在栈不为空的情况下，出栈操作只需要返回 `top` 位置的元素，然后更新 `top` 索引，时间复杂度为 \(O(1)\)。
    - **链表实现**：链表实现栈的出栈操作只需要删除链表头部节点，更新头指针，时间复杂度也是 \(O(1)\)。

### 4. 灵活性

- **数组实现**： 数组的大小在创建时就固定了，如果需要改变栈的容量，需要进行扩容或缩容操作，相对不灵活。
- **链表实现**： 链表可以根据需要动态地添加或删除节点，不需要预先分配固定大小的空间，在处理元素数量不确定的情况时更加灵活。



